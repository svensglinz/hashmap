% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hashmapR.R
\name{hashmap}
\alias{hashmap}
\title{Create a Hashmap Object}
\usage{
hashmap()
}
\description{
A \code{hashmap} provides a key-value store where keys and values
can be any R object that is serializable. Internally, it uses a
C++ \code{std::unordered_map} for efficient storage and lookup.
}
\details{
\subsection{Serialization}{

External pointers cannot be directly serialized in R. To save or
transfer a hashmap, you can convert it to a list using
\code{map$to_list()}, which returns a standard R list representation.
You can restore a hashmap from such a list using \code{map$from_list(...)}.
}

\subsection{Key Equality}{

Keys are considered equal if \code{identical(k1, k2) == TRUE}.
This strict equality means that numeric objects like \code{1L} (integer)
and \code{1} (double) are not considered equal.
}

\subsection{Copy on Insert}{

On each insertion of a key, value pair, the R objects are duplicated to prevent potential
issues with modifications.
}

\subsection{Methods}{

A hashmap object exposes the following methods:
\describe{
\item{\code{map$set(key, value, replace = FALSE, vectorize = FALSE)}}{
Set the value associated with a key in the hashmap.

If \code{replace=TRUE}, the value will replace the old value in case the map already
contains an element with the same key.

If \code{vectorize = TRUE}, both \code{key} and \code{value} must be lists of the same length.
Each element of the \code{key} list is paired with the corresponding element of the \code{value} list,
and all pairs are inserted into the hashmap.
}

\item{\code{map$get(key, vectorize = FALSE)}}{
Retrieve the value associated with a key. Returns NULL if the elment does not exist

If \code{vectorize=TRUE}, \code{key} must be a list and each element of the \code{key} list will be looked up separately.
The result is returned as a list.
}

\item{\code{map$delete(key, vectorize = FALSE)}}{
Remove a key-value pair from the map.

If \code{vectorize=TRUE}, \code{key} must be a list. Each element in the list will be deleted separately.
}

\item{\code{map$contains(key, vectorize=FALSE)}}{

Check if a key exists in the map. Returns TRUE/FALSE.

If \code{vectorize=TRUE}, \code{key} must be a list. Existense will be checked
for each item in the list.
}

\item{\code{map$keys()}}{Returns a list of all keys.}
\item{\code{map$values()}}{Returns a list of all values.}
\item{\code{map$to_list()}}{
Serialize the hashmap to a standard R list.
Returns a list with two sublits (keys, values)
}
\item{\code{map$from_list(lst)}}{
Restore hashmap contents from a list.
Returns the restored hashmap
}

\item{\code{map$clone()}}{
Returns a duplicate of the map
}

\item{\code{map$invert(duplicates=c("stack", "first"))}}{
Invert the hashmap by swapping keys and values. Returns a new hashmap where
the original values become keys and the original keys become values.

The \code{duplicates} parameter controls how to handle cases where multiple keys
map to the same value:
\itemize{
\item \code{"first"}: Keep only the first key encountered for each value
\item \code{"stack"}: Store all keys that map to the same value as a list
}
}
}
}
}
\examples{
# create hashmap object
library(hashmapR)
m <- hashmap()

# insert key, value pair into hashmap
# any serializable R value can be uesd as a key and value
m$set("key", "value")
m$set(1, 2)
m$set(mtcars, Sys.Date())

#' # alternative to $set()
m["key"] <- "value"

# insert key, value pairs (vectorized)
# if vectorized is not set to TRUE, the list itself is inseted as a single key / value
m$set(list(1, 2, 3), list("one", "two", "three"), vectorize = TRUE)

# retreive values
m$get(1)
m$get(list(1, 2, 3), vectorize = TRUE)

#' # alternatively (for single lookups)
m[1]

# remove values 
m$remove(1)
m$remove(mtcars)

# remove values (vectorized)
m$remove(list(1, 2, 3), vectorize = TRUE)

# return number of items in map 
m$size()

# return keys as a list
m$keys()

# return values as a list
m$values()

# clear map
m$clear()

# duplicate map
m$clone()

# invert map (stack duplicates)
m$invert(duplicates="stack")

# return 
}
